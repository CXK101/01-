1. 分支限界法（Branch and Bound）
解释： 分支限界法是一种通过树形结构搜索所有可能解的算法。通过剪枝的方式避免了不必要的搜索，提升了效率。在解决 01 背包问题时，通常会将每个物品放入背包或不放入背包作为树的分支。通过估算当前节点的上界（即当前已选择物品的价值加上最大可能的剩余价值），如果上界小于已知的最优解，则可以剪枝。

时间复杂度： 最坏情况下，分支限界法的时间复杂度与暴力搜索相同，即 O(2^n)，但是通过有效的剪枝，通常能大大减少搜索空间。

空间复杂度： 空间复杂度通常取决于存储搜索树的深度，一般为 O(n)，因为深度最多为物品的数量 n。

2. 回溯法（Backtracking）
解释： 回溯法通过递归地搜索所有解空间。在每一层递归中，判断当前物品是否放入背包，递归进入下一层。与分支限界法类似，回溯法也有剪枝的策略。通过提前停止不可能获得更优解的路径，来减少计算量。

时间复杂度： 回溯法最坏情况下的时间复杂度为 O(2^n)，因为每个物品都有两种选择（放入或不放入）。

空间复杂度： 空间复杂度为 O(n)，用于递归调用栈。

3. 记忆化搜索（Memoization）
解释： 记忆化搜索是一种将递归中的子问题解缓存的技术。对于每一个状态（当前背包重量和考虑到的物品），记录下该状态下的最优解，避免重复计算。在 01 背包问题中，状态通常用一个二维数组表示，其中 dp[i][w] 表示前 i 个物品放入容量为 w 的背包中的最大价值。

时间复杂度： 时间复杂度为 O(n * W)，其中 n 是物品数量，W 是背包容量。每个状态（共 n * W 个）最多计算一次。

空间复杂度： 空间复杂度为 O(n * W)，用于存储每个子问题的解。

4. 近似算法（Approximation Algorithm）
解释： 近似算法通过某些启发式方法，给出一个近似的解，而非精确解。通常用于面对 NP-hard 问题时，无法在多项式时间内找到最优解时，采用近似算法。例如，贪心算法就是一种常见的近似算法，它通过局部最优选择来近似全局最优解。

时间复杂度： 贪心算法的时间复杂度一般为 O(n log n)（排序的时间复杂度），对于某些简单的贪心算法可能是 O(n)。

空间复杂度： 空间复杂度通常为 O(n)，用于存储物品的相关信息。

5. 动态规划（Dynamic Programming）
解释： 动态规划法是 01 背包问题最经典的解法。通过将问题分解为子问题，逐步求解并存储子问题的解，避免重复计算。动态规划使用一个二维数组 dp[i][w] 来表示考虑前 i 个物品，背包容量为 w 时的最大价值。

时间复杂度： 时间复杂度为 O(n * W)，其中 n 是物品数量，W 是背包容量。因为每个状态只计算一次，且每个状态有常数时间的操作。

空间复杂度： 空间复杂度为 O(n * W)，用于存储每个子问题的解。

6. 暴力搜索（Brute Force）
解释： 暴力搜索法通过穷举所有物品的可能组合来求解 01 背包问题。对于每个物品，都有两种选择（放入背包或不放入背包），所以一共有 2^n 种可能的选择。

时间复杂度： 时间复杂度为 O(2^n)，因为每个物品有两种选择，且一共要遍历所有的物品组合。

空间复杂度： 空间复杂度为 O(1)，因为只需要存储当前的最优解。

7. 滚动数组法（Rolling Array）
解释： 滚动数组法是对动态规划的一种优化。由于在计算每个状态时，只需要依赖上一行（或者当前行）和当前物品的状态，因此可以将二维数组优化成一维数组，通过滚动更新状态，减少空间消耗。

时间复杂度： 时间复杂度为 O(n * W)，与传统动态规划相同。

空间复杂度： 空间复杂度优化为 O(W)，因为只需要一个大小为 W + 1 的一维数组来存储每个背包容量的最大值。
